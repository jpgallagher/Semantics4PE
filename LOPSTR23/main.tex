%\documentclass[11pt]{article}
\documentclass{llncs}

\usepackage{graphicx}
\usepackage{amsmath} 

\pagenumbering{arabic}

\newcommand{\integ}{{\sf int}}
\newcommand{\listint}{{\sf listint}}
\newcommand{\other}{{\sf other}}
\newcommand{\true}{\mathsf {true}}
\newcommand{\false}{\mathsf {false}}
\newcommand{\Res}{{\sf Res}}
\newcommand{\Bin}{{\sf Bin}}
\newcommand{\Dep}{{\sf Dep}}
\newcommand{\g}{{\sf g}}
\newcommand{\nong}{{\sf ng}}
\newcommand{\OL}{{\cal O}}
%\newcommand{\mgu}{{\sf mgu}}
\newcommand{\M}{{\sf M}}
\newcommand{\R}{{\cal R}}
\newcommand{\A}{{\cal A}}

\newcommand{\B}{{\cal B}}
\newcommand{\C}{{\cal C}}
\newcommand{\D}{{\cal D}}
\newcommand{\X}{{\cal X}}
\newcommand{\V}{{\cal V}}
\newcommand{\Q}{{\cal Q}}
\newcommand{\F}{{\sf F}}
\newcommand{\N}{{\cal N}}
\newcommand{\Lang}{{\cal L}}
\newcommand{\powerset}{{\cal P}}
\newcommand{\FTA}{{\cal FT\!A}}
\newcommand{\Term}{{\sf Term}}
\newcommand{\Empty}{{\sf empty}}
\newcommand{\nonEmpty}{{\sf nonempty}}
\newcommand{\compl}{{\sf complement}}
\newcommand{\args}{{\sf args}}
\newcommand{\preds}{{\sf preds}}
\newcommand{\gnd}{{\sf gnd}}
\newcommand{\lfp}{{\sf lfp}}
\newcommand{\psharp}{P^{\sharp}}
\newcommand{\minimize}{{\sf minimize}}
\newcommand{\headterms}{\mathsf{headterms}}
\newcommand{\solvebody}{\mathsf{solvebody}}
\newcommand{\solve}{\mathsf{solve}}
\newcommand{\fail}{\mathsf{fail}}
\newcommand{\member}{\mathsf{memb}}
\newcommand{\ground}{\mathsf{ground}}



\newcommand{\transitions}{\mathsf{transitions}}
\newcommand{\nonempty}{\mathsf{nonempty}}
\newcommand{\dom}{\mathsf{dom}}


\newcommand{\Args}{\mathsf{Args}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\type}{\tau}
\newcommand{\restrict}{\mathsf{restrict}}
%\newcommand{\any}{\mathsf{any}}
\newcommand{\any}{\top}
\newcommand{\dyn}{\top}
\newcommand{\dettypes}{{\sf dettypes}}
\newcommand{\Atom}{{\sf Atom}}


\newcommand{\vars}{\mathsf{vars}}
\newcommand{\Vars}{\mathsf{Vars}}
\newcommand{\range}{\mathsf{range}}
\newcommand{\varpos}{\mathsf{varpos}}
\newcommand{\varid}{\mathsf{varid}}
\newcommand{\argpos}{\mathsf{argpos}}
\newcommand{\elim}{\mathsf{elim}}
\newcommand{\pred}{\mathsf{pred}}
\newcommand{\predfuncs}{\mathsf{predfuncs}}
\newcommand{\project}{\mathsf{project}}
\newcommand{\reduce}{\mathsf{reduce}}
\newcommand{\positions}{\mathsf{positions}}
\newcommand{\contained}{\preceq}
\newcommand{\equivalent}{\cong}
\newcommand{\unify}{{\it unify}}
\newcommand{\Iff}{{\rm iff}}
%\newcommand{\And}{{\rm and}}
\newcommand{\Where}{{\rm where}}
\newcommand{\State}{\mathsf{S}}
\newcommand{\qmap}{{\sf qmap}}
\newcommand{\fmap}{{\sf fmap}}
\newcommand{\ftable}{{\sf ftable}}
\newcommand{\Qmap}{{\sf Qmap}}
\newcommand{\states}{{\sf states}}
\newcommand{\head}{\tau}

\newcommand{\keyword}[1]{\mathsf{#1}}
\newcommand{\SKIP}{\keyword{skip}}
\newcommand{\RET}[1]{\keyword{return}\,#1}
\newcommand{\ASG}[2]{#1 := #2}
\newcommand{\SEQ}[2]{#1\,{;}\,#2}
\newcommand{\IFNZ}[3]{\keyword{if} \,(#1)\, #2\,\keyword{else}\,#3}
\newcommand{\FOR}[4]{\keyword{for} \,(#1\,#2\,#3)\, #4}
\newcommand{\WHILE}[2]{\keyword{while} \,(#1)\, #2}


\usepackage{listings} 
\usepackage{courier}
\lstset{
%
%
  %
  stringstyle=\ttfamily,
  showstringspaces = false,
  basicstyle=\linespread{0.9}\footnotesize\ttfamily,
  commentstyle=\small\emph,
  keywordstyle=\small\bfseries,
  %
  numbers=none,
  mathescape=true,
  numbersep=3pt,
  numberstyle=\tiny,
  numberfirstline=true,
  breaklines=true,
  language=C,
  xleftmargin=1em,
  morekeywords={if,then,else,do,return,length,let,seq,asg,function,call,ret,ifthenelse,block,skip},
  deletekeywords={static,struct,call},
  columns=[l]flexible
}

\def\ll{[\![}
\def\rr{]\!]}

\newcommand{\todo}[1]{\textbf{**}\marginpar{\fbox{
\begin{minipage}{\oddsidemargin}
\textsf{{\small#1}}
\end{minipage}
}}}

\newcommand{\sset}[2]{\left\{~#1  \left|
                               \begin{array}{l}#2\end{array}
                          \right.     \right\}}


\newcommand{\qin}{\hspace*{0.15in}}
\newenvironment{SProg}
     {\begin{small}\begin{tt}\begin{tabular}[t]{l}}%
     {\end{tabular}\end{tt}\end{small}}
\def\anno#1{{\ooalign{\hfil\raise.07ex\hbox{\small{\rm #1}}\hfil%
        \crcr\mathhexbox20D}}}


\title{Transforming big-step to small-step semantics using interpreter specialisation}


\author{John P. Gallagher \thanks{Email. \texttt{jpg@ruc.dk}}\inst{1}\inst{2}
\and
Manuel Hermenegildo\inst{2}  \and Jos\'e Morales
\inst{2} \and Pedro L\'opez Garc\'ia\inst{2} 
}

\institute{Roskilde University, Denmark
\and
IMDEA Software Institute, Madrid, Spain}


\begin{document}
\maketitle
\input{abstract}

\pagestyle{plain}
\pagestyle{myheadings}

\section{Introduction}

The goal of this work is to transform big-step operational semantics to small-step operational semantics.
This has previously been studied \cite{Vesely-Fisher,Hulzing,Ambal}, as has the related problem of deriving abstract
machines from big-step semantics \cite{Ager}. The main novelty is the method, which we consider to be more
direct and more easily verifiable than previous approaches.  We formulate the transformation as the specialisation of a
linearising interpreter for big-step semantic rules.  Once a suitable interpreter has been written, in which the general
definition of a ``small step" has been encoded, the transformation
consists of partially evaluating it with respect to given big-step semantics.  The specialised interpreter contains the 
small-step transition rules, 
with minor syntactic modification. We describe experiments using an off-the shelf partial evaluator 
for logic programs \cite{Logen}.

In Section \ref{background} we review the notions of big-step and small-step semantics, and
the essential concepts behind program transformation using interpreter specialisation, with focus on interpreters for
Horn clause programs. Section \ref{small-step-interp} describes our interpreter for big-step semantic rules,
written in a linear style. Section \ref{examples} shows the results of experiments in specialising the interpreter.

\section{Background}\label{background}

\subsection{Operational Semantics}
Natural semantics (NS) was explicitly proposed by Kahn in the 
1980s \cite{Kahn87}; the name indicates an analogy with natural deduction. 
Structural operational semantics (SOS) was developed by Plotkin \cite{Plotkin1981,Plotkin04,Plotkin04a}.  
The motivation of SOS was to define
``machine-like" execution of programs, but in a syntax-directed style, omitting all unnecessary details of
the machine.  Both styles have their advantages, which we do not discuss in detail here.

The nicknames \emph{big-step} and \emph{small-step} for NS and SOS respectively have been used
since at least the early 1990s, and we use them in the rest of the paper, since they neatly
express the difference between NS and SOS.  Both approaches define the behaviour of a program
as runs in a transition system, whose configurations are of the form $\langle s, \sigma\rangle$ where $s$ is a
syntactic expression (such as a statement) and $\sigma$ is a program state; sometimes $s$ is omitted when it is empty
or associated with a final state.  

In big-step semantics, transitions are of the form $\langle s, \sigma\rangle \Longrightarrow \sigma'$, 
which means that $s$ is completely executed in state $\sigma$, terminating in final state $\sigma'$.
The name \emph{big-step} semantics arises since the transition for a statement goes from the initial to the final state.  
%
By contrast, in small-step semantics, a transition has the form $\langle s, \sigma\rangle \Rightarrow \langle s',\sigma'\rangle$, 
which defines a single step
that moves from $s$ in state $\sigma$ to the \emph{next} statement $s'$ and next state $\sigma'$. We may also have a transition
$\langle s, \sigma\rangle \Rightarrow \sigma'$ for the case that $s$ terminates in one step.
A computation or run is defined as a 
chain of small steps.  Note that we use $\Longrightarrow$ and $\Rightarrow$ for big and small-step transitions respectively.

\subsection{Interpreter specialisation}

The idea of specialising a program with respect to partial input,  known as program specialisation, partial evaluation or mixed computation, 
originated in the 1960s \cite{Lombardi,Ershov}.  In 1971, Futamura discussed the specialisation of interpreters, and its connection to compilers and compiler 
generators \cite{Futamura71}.  In particular, the specialisation of a program interpreter with respect to an object program,  but with unknown
program state (known as the first Futamura projection) is analogous to compilation of the object 
program into the language in which the interpreter is written.  
When the interpreter is written in the same language as that of the object program,
the result of specialisation may be viewed as a source transformation of the object program 
(whereas it is in fact a transformation of the interpreter). 
The transformation can be regarded as the imposition of (possibly non-standard) semantics encoded in the
interpreter onto the object program. 
This idea was exploited to transform programs, \cite{Gallagher,Turchin,Glueck,Jones,Giacobazzi}, and can result in deep changes in program structure, 
possibly yielding superlinear speedups, in contrast to partial evaluation itself, which gives only linear speedups and does not fundamentally alter program
structure.  Furthermore, it has been shown that some established program transformations such as deforestation
can be realised as interpreter specialisation \cite{Glueck}.  A transformation technique for logic programs with a similar 
aim, \emph{compiling control} \cite{BruynoogheDeS},
has also been shown to be realisable as interpreter specialisation \cite{Nys}.

The idea of transformation by interpreter specialisation is thus well known, yet its potential has not been fully realised, probably due to the 
fact that effective specialisation of complex interpreters is beyond the power of general purpose program specialisers and needs 
further research \cite{GallagherGlueck}.

\subsection{Horn clause representation of semantics and interpreters}

Both big-step and small-step transitions have the form of rules with premises and conclusion, typically written in the following form.
\[
\dfrac{\mathit{premises}} 
{\mathit{conclusion}} 
~~~~\mathrm{if }~ \mathit{condition}
\]
With a suitable encoding of syntactic objects and program states as first-order terms, this is a first-order logic implication
$\mathit{premises} \wedge \mathit{condition} \rightarrow \mathit{conclusion}$ 
The conclusion is an atomic formula
$\langle s, \sigma\rangle \Longrightarrow \sigma'$ (big-step) or $\langle s, \sigma\rangle \Rightarrow \langle s',\sigma'\rangle$ (small-step),
where $\Longrightarrow$ and $\Rightarrow$ are first order predicates, so assuming that the premises and conditions are conjunctions,
the transition rules are Horn clauses.

The close connection between transition rules and Horn clauses, and hence to the logic programming language Prolog, 
was noticed by Kahn and his co-workers in their work on big-step semantics.
A set of big-step transition rules written as Horn clauses can be executed as a logic program. This was exploited in
the Typol tool \cite{Typol}. Similarly, small step transition rules, together with a rule specifying a run of
small-step transitions, can also be regarded as a logic program.

Interpreters for logic programs can themselves be written as logic programs, where the program being interpreted 
is represented in some suitable way as a data structure in the interpreter.  

We summarise our approach as follows.  Let $I(x,y)$ be a logic program implementing an interpreter for a set of
big-step semantics rules $x$ and an object program $y$. $I$ is written in a small-step style (see next section).  Let logic program $B$ be the big-step semantics
for some programming language, and let $\lceil B \rceil$ be the representation of $B$ in the interpreter.  Then we specialise 
$I(\lceil B \rceil,y)$.  The resulting specialised interpreter $I_B(y)$ is a logic program containing (after some minor syntactic modification) 
the small-step semantic rules
corresponding to $B$.

In the following, we use Prolog syntax and teletype font for Horn clauses.

\section{A small-step interpreter for big-step semantics}\label{small-step-interp}

\paragraph{Linear interpretation.}  Figure \ref{fig:linear-interp} shows the main clauses of a linear interpreter for any Horn clause program $P$.  
The predicate \texttt{clause(Head,Body)} is used to access the clauses of $P$.  The predicate \texttt{solve(As)} has as argument a stack of atoms, and
at each step the atom  \texttt{A} at the top of the stack is replaced by the (instance of the) body of a clause whose head unifies with \texttt{A}.
(We ignore for now the treatment of builtin predicates such as arithmetic predicates).
To run a goal \texttt{A} in $P$ we execute \texttt{run([A])} in the interpreter.  
Correctness of the interpreter follows from the soundness and completeness of linear resolution.
\begin{figure}
\begin{tabular}{l}
\begin{lstlisting}
solve([A|As]) :-  clause(A,B), append(B,As,As1), solve(As1).
solve([]).
\end{lstlisting}
\end{tabular}
\caption{Clauses from a linear interpreter.}\label{fig:linear-interp}
\end{figure}

This interpreter could be specialised with respect to a given $P$.  The outcome corresponds roughly to transforming $P$ to continuation-passing
style, also known as binary logic programs \cite{Demoen}.

\paragraph{Linear interpreter for big-step semantics.} 
Our interpreter for big-step semantics is a linear interpreter of big-step semantics; however,  
instead of performing just one resolution step on each cycle of the interpreter,
as in Figure \ref{fig:linear-interp}, we wish to execute a number of resolution steps corresponding to whatever we define to be a ``small step" in the 
program execution.  The main interpreter loop thus has the form shown in Figure \ref{fig:linear-bigstep}.
\begin{figure}
\begin{tabular}{l}
\begin{lstlisting}
solve([A|As]) :- smallStep(A,As,As1), solve(As1).
solve([]).
\end{lstlisting}
\end{tabular}
\caption{Core of the linear big-step interpreter.}\label{fig:linear-bigstep}
\end{figure}

The definition of the interpreter predicate \texttt{smallStep} is the crucial part of the whole interpreter.
We now look more closely at the form of big-step transition rules, which will lead us to its definition. 
Following \cite{Nielsons}, we take the general form of big-step rules to
be as follows.
\[
\dfrac{\langle s_1, \sigma_1\rangle \Longrightarrow \sigma'_1, \ldots, \langle s_n, \sigma_n\rangle \Longrightarrow \sigma'_n}
{\langle s, \sigma\rangle \Longrightarrow \sigma'} 
~~~~\mathrm{if }~ c
\]
This will be rendered as a Horn clause as follows.
\begin{lstlisting}
bigstep(S,M0,M01):-C,bigstep(S1,M1,M11),...,bigstep(Sn,Mn,Mn1)
\end{lstlisting}
If the premises are empty ($n=0$) we call the rule an \emph{axiom}.  The syntax elements appearing as $s$ in the conclusion 
are of the form $s=f(s'_1,\ldots,s'_k)$, where $s'_1,\ldots,s'_k$ are the immediate constituents of $s$.  Note that the immediate constituents 
are not necessarily the same as the $s_1,\ldots,s_n$ in the premises.  We assume that each syntax constructor $f$ appears in the conclusion
of one or more rules, and that a constructor does not appear in the conclusion of both an axiom and non-axiom. Given a syntax term $s=f(t_1,\ldots,t_k)$,
we call $s$ a \emph{leaf} if $f$ appears in the conclusion of one or more axiom, otherwise $s$ is called a \emph{non-leaf}.

\paragraph{Definition of a small step.} We now proceed to define \texttt{smallStep} in stages, to motivate its construction.
The first version is shown in Figure \ref{fig:linear-smallstep}.
A small step, when executing the big-step semantics, is the application of one axiom.  
The application of the non-axioms may be seen as reductions of the syntax
term into its constituent terms (or other terms constructed from them), and hence does not actually \emph{do} anything computational.
Our first definition of the \texttt{smallStep} relation is thus as follows. It repeatedly applies rules so long as the top of stack is a non-leaf; when 
the top of stack is a leaf, it executes the condition of the axiom, represented by the call \texttt{eval(Bs)}, and terminates.  
Note that \texttt{smallStep}
is a recursive predicate, and its execution may take many step, depending on how deep the syntax term is.

\begin{figure}
\begin{tabular}{l}
\begin{lstlisting}
smallStep(bigstep(A,St,St1),As,As) :- 
    leaf(A),
    clause(bigstep(A,St,St1), Bs),
    eval(Bs).
smallStep(bigstep(A,St,St1),As,As1) :- 
    nonLeaf(A),
    clause(bigstep(A,St,St1), [B|Bs]),
    append([B|Bs],As,[B|Bs1]),
    smallStep(B,Bs1,As1).
\end{lstlisting}
\end{tabular}
\caption{First definition of a small step.}\label{fig:linear-smallstep}
\end{figure}

Consider now the second clause for \texttt{smallStep}, handling a non-leaf.  We know that the clause to be applied has at least one
call to \texttt{bigstep} in the body, since it is not an axiom. Hence we can consider the first such call (the variable \texttt{B} in the clause).
If it is a leaf, \texttt{smallStep} will terminate on the next step, otherwise it is a non-leaf and \texttt{smallStep} will be called recursively.
This information is needed in order to construct recursive small-step rules handling the non-leaf constructs. Adding this to the definition of
\texttt{smallStep}, we get the code shown in Figure \ref{fig:linear-nextstep}.

\begin{figure}
\begin{tabular}{l}
\begin{lstlisting}
smallStep(bigstep(A,St,St1),As,As) :- 
    leaf(A),
    clause(bigstep(A,St,St1), Bs),
    eval(Bs).
smallStep(bigstep(A,St,St1),As,As1) :- 
    nonLeaf(A),
    clause(bigstep(A,St,St1), [B|Bs]),
    append([B|Bs],As,[B|Bs1]),
    nextStep(B,Bs1,As1).
    
nextStep(A,As,As) :-
    leaf(A),
    smallStep(A,As,As).
nextStep(A,As,As1) :-
    nonLeaf(bigstep(A,St0,St1)),
    smallStep(bigstep(A,St0,St1),As,As1).
\end{lstlisting}
\end{tabular}
\caption{Enhanced small step definition, with next step lookahead.}\label{fig:linear-nextstep}
\end{figure}

\paragraph{Folding to eliminate the stack.}  So far, the interpreter still handles a stack; yet small-step semantics (at least in its standard form)
contains no stack.  We now show how to eliminate the stack from the interpreter;  more precisely, we show how to apply folding so that it
contains at most one call to \texttt{bigstep}.

Consider again the general form of a big-step rule with $n$ premises, where $n>0$ (a non-axiom).  For the moment,
assume that $n\le 2$.  We discuss the general case later. The constructor $f$ is shown in
the conclusion.  
\[
\dfrac{\langle s_1, \sigma_1\rangle \Longrightarrow \sigma'_1 ~~~\langle s_2, \sigma_2\rangle \Longrightarrow \sigma'_2}
{\langle f(s'_1,\ldots,s'_k), \sigma\rangle \Longrightarrow \sigma'} 
~~~~\mathrm{if }~ c
\]

\begin{figure}
\begin{tabular}{l}
\begin{lstlisting}
smallStep(A,[]) :-
	leaf(A),
	clause(_,A,Bs),
	eval(Bs).
smallStep(bigstep(A,St0,St1),As1) :-
	nonLeaf(bigstep(A,St0,St1)),
	clause(K,bigstep(A,St0,St1),[B|Bs]),
	nextStep(B,K,Bs,As1).
	
nextStep(A,_,Bs,Bs) :-
	leaf(A),
	smallStep(A,[]).
nextStep(bigstep(A,St0,St1),K,Bs,[bigstep(U,V,W)]) :-
	nonLeaf(bigstep(A,St0,St1)),
	smallStep(bigstep(A,St0,St1),[bigstep(U,V,W)]),
	tryFold(K,H,[bigstep(U,V,W)|Bs]).
	
tryFold(_,B1,[B1]).
tryFold(K,H,[B1|Bs]) :-
	Bs \== [],
	clause(K,H,[B1|Bs]).
\end{lstlisting}
\end{tabular}
\caption{Definition of a small step, with folding of the stack.}\label{fig:linear-fold}
\end{figure}

Small step evaluation of such a rule consists of treating the arguments from left to right, applying small steps to the first premise until it
is completed, then moving to the second. For example, consider the imperative statement sequence $s_1;s_2$. Execution of the
first premise may take several small steps: $\langle s_1, \sigma_1\rangle, \langle s_{1,1}, \sigma_{1,1}\rangle, \langle s_{1,2}, \sigma_{1,2}\rangle, \ldots \sigma_1$.
Execution then moves to $\langle s_2, \sigma_1\rangle$.  
In small step execution, the context of the execution of the first component it
maintained by substituting the partial results in the syntactic functor in the conclusion. Thus the small-step execution of $s_1;s_2$ follows the sequence
$$\langle s_1;s_2, \sigma_1\rangle, \langle s_{1,1};s_2, \sigma_{1,1}\rangle, \langle s_{1,2};s_2, \sigma_{1,2}\rangle, \ldots \langle s_2,\sigma_1\rangle,\ldots$$

The construction of the context of the rule conclusion is achieved in the interpreter by trying to fold the current stack of goals using the 
clause that was used to produce it. Either the stack contains only one goal, in which case no folding is needed, or
the height of the stack just before folding is two and so has the form required to fold with the rule clause.
Adding the folding operation gives the code for \texttt{smallStep} shown in Figure \ref{fig:linear-fold}. 
Note that the second argument of \texttt{smallStep} in the previous figures is always \texttt{[]} (since the height of the stack is at most one), we
omit that argument, leaving \texttt{smallStep} with only two arguments.

\begin{figure}
\[
\begin{array}{l|l}
 \dfrac{ } 
{\langle \ASG{x}{e}, \sigma \rangle \Longrightarrow \sigma[x/v]}
 ~~~\text{if } V e \sigma = v~


&~~~
\dfrac{\langle s_1, \sigma \rangle \Longrightarrow \sigma' } 
{\langle \IFNZ{b}{s_1}{s_2}, \sigma \rangle \Longrightarrow \sigma'}
 ~~~~~~~\text{if } V b \sigma = \true\\
 \\
\dfrac{\langle s_1, \sigma \rangle \Longrightarrow \sigma' ~~~~\langle s_2, \sigma' \rangle \Longrightarrow \sigma''} 
{\langle \SEQ{s_1}{s_2}, \sigma \rangle \Longrightarrow \sigma''}~~~
&~~~
\dfrac{\langle s_2, \sigma \rangle \Longrightarrow \sigma' } 
{\langle \IFNZ{b}{s_1}{s_2}, \sigma \rangle \Longrightarrow \sigma'}
 ~~~~~~~\text{if } V b \sigma = \false\\
 \\
 
 ~
&~~~
\dfrac{\langle \IFNZ{b}{s;\WHILE{b}{s}}{\SKIP}, \sigma \rangle \Longrightarrow \sigma'} 
{\langle \WHILE{b}{s}, \sigma \rangle \Longrightarrow \sigma'}
\\
\\
\dfrac{} 
{\langle \SKIP, \sigma \rangle \Longrightarrow \sigma}
 ~
&
\dfrac{\langle \mathit{init}, \sigma \rangle \Longrightarrow \sigma' ~~~~\langle \WHILE{b}{\SEQ{s}{\mathit{incr}}}, \sigma' \rangle \Longrightarrow \sigma''} 
{\langle \FOR{\mathit{init}}{b}{\mathit{incr}}{s}, \sigma \rangle \Longrightarrow \sigma''}
\\
 \end{array}
\]
\caption{Big-step rules for a small imperative language.}\label{big-step-trans}
\end{figure}

\section{Examples}\label{examples}




Figure \ref{big-step-trans} shows the big-step semantics for a small imperative language containing assignments , statement composition,
if-then-else, while and for statements.  We assume a function $V$ that evaluates expressions and conditionals in a state.  
Specialising our small-step interpreter with respect for these rules gives the output shown in Figure \ref{small-step-while}. While a few of the
arguments are redundant, the small-step rules shown in Figure \ref{small-step-rules} can be directly extracted.  The first clause for \texttt{while}
(the 7th clause for \texttt{smallStep}) contains the body goal \texttt{leaf5(bigstep(ifthenelse(...))} which fails and so that clause can be eliminated.
In general, the control of the partial evaluator {\sc  Logen}  is a balance between unfolding too much and unfolding too little, so such cases are 
difficult to eliminate.
\begin{figure}
\begin{tabular}{l}
\begin{lstlisting}
smallStep1(skip,A,A,[]).
smallStep1(asg(var(D),C),A,B,[]) :-
    eval3(C,A,E,F),
    eval4(D,F,E,B).
smallStep1(seq(C,D),A,B,[bigstep(D,E,B)]) :-
    leaf5(bigstep(C,A,E)),
    smallStep1(C,A,E,[]).
smallStep1(seq(C,D),A,B,[bigstep(seq(F,D),E,B)]) :-
    nonLeaf6(bigstep(C,A,G)),
    smallStep1(C,A,G,[bigstep(F,E,G)]).
smallStep1(ifthenelse(C,D,_),A,B,[bigstep(D,E,B)]) :-
    leaf5(controlExpr(C,A,E,1)),
    smallStep2(C,A,E,1,[]).
smallStep1(ifthenelse(C,_,D),A,B,[bigstep(D,E,B)]) :-
    leaf5(controlExpr(C,A,E,0)),
    smallStep2(C,A,E,0,[]).
smallStep1(while(C,D),A,B,[]) :-
    leaf5(bigstep(ifthenelse(C,seq(D,while(C,D)),skip),A,B)),
    smallStep1(ifthenelse(C,seq(D,while(C,D)),skip),A,B,[]).
smallStep1(while(C,D),A,B,[bigstep(E,F,G)]) :-
    nonLeaf6(bigstep(ifthenelse(C,seq(D,while(C,D)),skip),A,B)),
    smallStep1(ifthenelse(C,seq(D,while(C,D)),skip),A,B,[bigstep(E,F,G)]).
smallStep1(for(C,D,E,F),A,B,[bigstep(while(D,seq(F,E)),G,B)]) :-
    leaf5(bigstep(C,A,G)),
    smallStep1(C,A,G,[]).
smallStep1(for(C,D,E,F),A,B,[bigstep(for(H,D,E,F),G,B)]) :-
    nonLeaf6(bigstep(C,A,I)),
    smallStep1(C,A,I,[bigstep(H,G,I)]).

\end{lstlisting}
\end{tabular}
\caption{Small step clauses for statements, in the specialised interpreter.}\label{small-step-while}
\end{figure}

\begin{figure}
\[
\begin{array}{l|l}
 \dfrac{ } 
{\langle \ASG{x}{e}, \sigma \rangle \Rightarrow \sigma[x/v]}
 ~~~~~~~\text{if } V e \sigma = v~~~

&~~~
\dfrac{} 
{\langle \SKIP, \sigma \rangle \Rightarrow \sigma}
\\
\\
\dfrac{\langle s_1, \sigma \rangle \Rightarrow \sigma' } 
{\langle \SEQ{s_1}{s_2}, \sigma \rangle \Rightarrow \langle s_2 \sigma'\rangle}~~~
&~~~
\dfrac{} 
{\langle \IFNZ{b}{s_1}{s_2}, \sigma \rangle \Rightarrow \langle s_1,\sigma'\rangle}
 ~~~~~~~\text{if } V b \sigma = \true\\
 \\
 \dfrac{\langle s_1, \sigma \rangle \Rightarrow \langle s_1', \sigma'\rangle} 
{\langle \SEQ{s_1}{s_2}, \sigma \rangle \Rightarrow \langle \SEQ{s_1'}{s_2}, \sigma'\rangle}~~~
 ~
&~~~
\dfrac{} 
{\langle \IFNZ{b}{s_1}{s_2}, \sigma \rangle \Rightarrow \langle s_2,\sigma'\rangle}
 ~~~~~~~\text{if } V b \sigma = \false\\
 \\
\dfrac{\langle \mathit{init}, \sigma \rangle \Rightarrow \sigma' } 
{\langle \FOR{\mathit{init}}{b}{\mathit{incr}}{s}, \sigma \rangle \Rightarrow \langle \WHILE{b}{\SEQ{s}{\mathit{incr}}}, \sigma' \rangle}
 ~
&~~~
\dfrac{\langle \IFNZ{b}{s;\WHILE{b}{s}}{\SKIP}, \sigma \rangle \Rightarrow \langle s_1,\sigma'\rangle} 
{\langle \WHILE{b}{s}, \sigma \rangle \Rightarrow \langle s_1,\sigma'\rangle}
\\
\\
 \dfrac{\langle \mathit{init}, \sigma \rangle \Rightarrow\langle \mathit{init}', \sigma' \rangle } 
{\langle \FOR{\mathit{init}}{b}{\mathit{incr}}{s}, \sigma \rangle \Rightarrow \langle \FOR{\mathit{init}'}{b}{\mathit{incr}}{s}, \sigma' \rangle}
 ~
&~~~
\\
 \end{array}
\]
\caption{Extracted small-step rules for a small imperative language.}\label{small-step-rules}
\end{figure}

\bibliographystyle{plain}
%\bibliographystyle{splncs}
\bibliography{refs}


\end{document}
